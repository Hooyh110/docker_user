# (十三) SQL语句

Rule 1. **【强制】不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL有关。**

说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。

---
Rule 2. **【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。**

---
Rule 3. **【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。**

正例：可以使用如下方式来避免sum的NPE问题  

```sql
SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;
```

Rule 4. **【强制】使用ISNULL()来判断是否为NULL值。**

说明：NULL与任何值的直接比较都为NULL。

1. NULL<>NULL的返回结果是NULL，而不是false。
2. NULL=NULL的返回结果是NULL，而不是true。
3. NULL<>1的返回结果是NULL，而不是true。

---
Rule 5. **【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。**

---
Rule 6. **【强制】不得使用外键与级联，一切外键概念必须在应用层解决。**

说明：以学生和成绩的关系为例，学生表中的`student_id`是主键，那么成绩表中的`student_id` 则为外键。如果更新学生表中的`student_id`，同时触发成绩表中的`student_id`更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。

---
Rule 7. **【推荐】谨慎的使用存储过程，存储过程难以调试和扩展，更没有移植性。**

---
Rule 8. **【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。**

---
Rule 9. **【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。**

---
Rule 10. **【参考】如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。**

---
Rule 11. **【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE 无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。**

说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。

---
Rule 12. **【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引**

说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

---
Rule 13. **【推荐】避免三个表以上的join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。**

说明：即使双表join也要注意表索引、SQL性能。

---
Rule 14. **【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。**

正例：`where a=? and b=? order by c;`索引：a_b_c  
反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引 a_b无法排序。

---
Rule 15. **【推荐】利用延迟关联或者子查询优化超多分页场景。**

说明：MySQL并不是跳过`offset`行，而是取`offset+N`行，然后返回放弃前`offset`行，返回 `N`行，那当`offset`特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。  
正例：先快速定位需要获取的id段，然后再关联：

```sql
 SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id;
```

---
Rule 16. **【推荐】建组合索引的时候，区分度最高的在最左边。**
正例：如果 `where a=? and b=?` ，如果a列的几乎接近于唯一值，那么只需要单建idx_a 索引即可。

说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：`where c>? and d=?` 那么即使c的区分度更高，也必须把d放在索引的最前列，即索引idx_d_c。

---
Rule 17. **【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。**

---
Rule 18. **【参考】创建索引时避免有如下极端误解**

1. 宁滥勿缺。认为一个查询就需要建一个索引。
2. 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
3. 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

Rule 18. **【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts 最好。**

说明：

1. consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2. ref 指的是使用普通的索引（normal index）。
3. range 对索引进行范围检索。

反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。

---